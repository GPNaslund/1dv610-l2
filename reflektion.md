# Kapitel 2
| NAMN & FÖRKLARING | REFLEKTIONER OCH REGLER FRÅN CLEAN CODE |
|-------------------|-----------------------------------------|
|**QuestionBank**<br>Namn på en av huvudklasserna klasserna<br> som används i publika interfacet.|**Don't be cute**<br> Klassens namn har en skämtsam ton och kan misstolkas i vad den utför.|
|**Question**<br>Namn på klass som används i modulen.|**Make meaningful distinctions**<br>Klassens namn saknar en meningsfull distinktion mellan olika sorters frågor. Namnet 'MultipleChoiceQuestion' hade gett ytterliggare meningsfull distinktion då klassen innehåller frågan, svarsalternativ, rätt svar samt kategori.<br><br> **Add meaningful context**<br> Genom att ha en klass som innehåller attribut så ges en kontext till tex fältet "text" då den tillhör klassen Question. Ytterliggare meningsfull kontext hade getts ifall klassens namn ändrades enl tidigare stycke.|
|**QuizEngine.initFilesystemStorage()**<br>Namn på en metod tillhörandes huvudklassen.|**Use intention revealing names**<br>Metoden använder delvis ett namn som förmedlar vad den gör. Att den initierar en lagring via filsystemet framgår, men förtydligande om vad och varför framgår inte. initFilesystemHighscoreStorage() hade kunnat vara ett bättre namn på metoden. <br><br>**Use solution domain names**<br>Namnet på metoden använder sig av förkortningen init vilket inom lösningsdomänen / programmering används som förkorting för initialize, vilket förenklar förståelsen av att metoden initierar något|
|**QuizEngine.on('correct')**<br>Namn på ett event som utlöses av huvudklassen.|**Add meningful context**<br> Eventets (som metoden lyssnar efter) namngivning är väldigt diffus. Att se metoden som lyssnar på händelsen utan mer kontext avslöjar egentligen ingenting om vad händelsen handlar om. En bättre namngivning hade kunnat vara 'answered-correct' eller liknande. <br><br>**Method name + Use solution domain names**<br> .on() metodanrop används ofta för funktionsanrop som beror på en händelse. Namngivningen illustrerar både att den utlöses "när något"/"på något" samt är en vanlig benämning av metoder som lyssnar på händelser.|
|**QuestionBank.createAndAddQuestion()**<br>Namn på en metod i en av huvudklasserna.| **Reveal Intent**<br>Metodens namn beskriver vad den gör tydligt.<br><br> **Use pronouncable names**<br> Metoden har ett namn som enkelt går att uttala och konversera om.<br> <br> **Method name is a verb**<br> Metodens namn är baserat på verb/handling, vilket förenklar förståelsen för att metoden gör något. |


# Kapitel 3
Jag insåg att mina funktioner ofta gjorde mer än en sak (bröt mot **do one thing**) samt att flertal funktioner översteg **triads** mängd av argument. Jag hittade bra tillfällen att skapa nya klasser som håller data (Ex; QuestionResult) där anonyma objekt tidigare användes, som möjliggjorde **monadiska** funktioner som tidigare hade flertal parametrar. Mina funktionsnamn tycker jag överlag är bra (**use descriptive names**) där det framgår relativt tydligt vad funktionen gör (ex startQuiz()), samtidigt som vissa funktionener skulle kunna förtydligas yterliggare (**add meaningful context**) i linje med reflektionerna gjorda i tabellen ovan. Jag håller med kapitlena till stor del, speciellt vid arbete med kod i javascript som saknar typsäkerhet. Samtidigt så reflekterar jag över den overhead som blir av att skapa både klasser och funktioner, vilket jag gissar på skulle kunna påverka prestanda negativt. Samtidigt är en onödig prestanda optimering i sig inte värd kod som är mindre läsbar, så utbytet av prestanda mot läsbarhet är värd för applikationer som inte nödvändigtvis behöver en optimal prestanda.


# Reflektion
Erfarenheterna av min egna kodkvalitet har varit insiktsfulla. För mig blev det ögonöppnande att inse hur många regler som min struktur och kod bröt mot initialt. Mina funktioner bröt i regel mot (**do one thing**) regeln, där jag tänkte mer på att samla ett flöde logiska steg på ett ställe jämfört med att förmedla en tydlig funktion, både i avseende av (**do one thing**) regeln samt (**reveal intent**). Mina funktioner löste i regel ett lite mindre uppdrag, istället för att utföra en specifik handling. Mina metoder innehöll oftast +3 (**triads**) argument, vilket jag då tyckte gav en funktion flexibilitet, men nu efter att ha läst boken och fått nya insikter så siktar jag på (**monadic**), (**dyadic**) eller max (**triads**) funktioner. Ett exempel på en ändring jag gjorde var att skapa en QuizResultSummary som innhåller en mängd CategorySummary, för att skapa en summering av hur ett quiz har gått, vilket innebär att objekt som dessa ges till funktioner istället för att värden (text, choices, correctChoice, wasCorrect, category, numOfQuestions etc).
Jag reflekterade även på att implementera ett builder mönster för klasser som naturligt behöver +3 argument där ett skapande av klass inte är helt intuitivt, men valde att i fåtal situationer låta metoder eller klass konstruktors att ta emot fler än tre argument.
Jag tycker att idén om att hålla funktioner små (**small!**) generellt är bra, samtidigt tycker jag att det logiska flödet blir avbrutet mer av att hoppa runt mellan flertal metoder för att förstå vad en samling av dem utför kan störa mer än det hjälper. Personligen försöker jag hålla funktionernas storlek på en rimlig nivå med ungefär en jämn abstraktionsnivå (**one level of abstraction per function**) är det jag personligen upplever som bäst. Att en funktion inte får ha sidoeffekt (**have no side effects**) är något som har tryckts på under utbildningen, men framförallt utifrån perspektivet av att en funktion inte får modifiera argument som skickas till den utan isåntfall ska kopiera dessa, modifiera och returnera den modifierade kopian. Det gav mig ett nytt perspektiv både i hur viktig utformningen är (**do one thing**) och namngivning (**reveal intent**) av en funktion när man inkluderar att en funktion har sidoeffekter ifall den gör något utöver det som kan förväntas av funktionen (baserat på namngivning och kontext), oavsett om den inte modifierar argumentet. Jag har tidigare upplevt att argument validering har varit svår att veta var man ska placera utan att helt förstöra funktionen som tar emot argumentet, men efter att jag läst **error handling is one thing** stycket så insåg jag dels hur mycket mer läsbart det är att ha all argumentvalidering i en separat funktion (som i sig kastar undantag/errors om fel påträffas), samt hur mycket mer nogrann validering av argument blir när man fokuserar på det som en separat del. Jag har hört mycket negativt om clean code på youtube, och förstår hur det kan bli om det går till överdrift, men för mig har det varit otroligt kul och utmananande att granska sin egna kod utifrån clean code perspektivet. Jag ser fram emot att fortsatta skriva om modulen samt att ta med viktiga insikter till framtida projekt.