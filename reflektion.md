# Kapitel 2
| NAMN & FÖRKLARING | REFLEKTIONER OCH REGLER FRÅN CLEAN CODE |
|-------------------|-----------------------------------------|
|**QuestionBank**<br>Namn på en av huvudklasserna klasserna<br> som används i publika interfacet.|**Don't be cute**<br> Klassens namn har en skämtsam ton och kan misstolkas i vad den utför.<br>Ett bättre namn hade kunnat vara "QuestionStorage".|
|**Question**<br>Namn på klass som används i modulen.|**Make meaningful distinctions**<br>Klassens namn saknar en meningsfull distinktion mellan olika sorters frågor. Namnet 'MultipleChoiceQuestion' hade gett ytterliggare meningsfull distinktion då klassen innehåller frågan, svarsalternativ, rätt svar samt kategori.<br><br> **Add meaningful context**<br> Genom att ha en klass som innehåller attribut så ges en kontext till tex fältet "text" då den tillhör klassen Question. Ytterliggare meningsfull kontext hade getts ifall klassens namn ändrades enl tidigare stycke.|
|**QuizEngine.initFilesystemStorage()**<br>Namn på en metod tillhörandes huvudklassen.|**Use intention revealing names**<br>Metoden använder delvis ett namn som förmedlar vad den gör. Att den initierar en lagring via filsystemet framgår, men förtydligande om vad och varför framgår inte. initFilesystemHighscoreStorage() hade kunnat vara ett bättre namn på metoden. <br><br>**Use solution domain names**<br>Namnet på metoden använder sig av förkortningen init vilket inom lösningsdomänen / programmering används som förkorting för initialize, vilket förenklar förståelsen av att metoden initierar något|
|**QuizEngine.on('correct', (scoreData) => {})**<br>Namn på ett event/callback som utlöses av huvudklassen.|**Add meningful context**<br> Eventets (som metoden lyssnar efter) namngivning är väldigt diffus. Att se metoden som lyssnar på händelsen utan mer kontext avslöjar egentligen ingenting om vad händelsen handlar om. En bättre namngivning hade kunnat vara 'answered-correct' eller liknande.<br>scoreData variabeln saknar också meningsfull kontext då det är ett anonymt objekt, att skapa en egen klass eller eventuellt låta eventet triggas med två separata element (playerName, score) hade troligvist varit tydligare.<br><br>**Method name + Use solution domain names**<br> .on() metodanrop används ofta för funktionsanrop som beror på en händelse. Namngivningen illustrerar både att den utlöses "när något"/"på något" samt är en vanlig benämning av metoder som lyssnar på händelser.|
|**QuestionBank.createAndAddQuestion()**<br>Namn på en metod i en av huvudklasserna.| **Reveal Intent**<br>Metodens namn beskriver vad den gör tydligt.<br><br> **Use pronouncable names**<br> Metoden har ett namn som enkelt går att uttala och konversera om.<br> <br> **Method name is a verb**<br> Metodens namn är baserat på verb/handling, vilket förenklar förståelsen för att metoden gör något. |
## Reflektion
Innehållet i kapitel två var väldigt intressant och ögonöppnande. Jag hade i vissa avseenden en uppfattning som var tvärt emot det boken lyfte som viktigt, ex att korta namn var bättre än namn om visar på intention och är uttalbara. Jag har i min modul namngivit en klass som "QuestionBank" och efter att ha läst Dont pun delen av kapitelet så förstod jag den "lite roliga" namngivningen kan försvåra förståelsen för någon annan om vad klassen faktiskt gör. Jag planerar att döpa om klassen efter nästa laboration. Jag håller helt med om att förslagen/reglerna i kapitel två är viktigt att följa i största möjliga mån för att öka läsbarheten av koden. Det blir tydligt vid praktiserandet av reglerna att det blir mycket lättare att förstå vad koden gör med en mer genomtänkt namngivning.


# Kapitel 3
| NAMN & FÖRKLARING | REFLEKTIONER OCH REGLER FRÅN CLEAN CODE |
|-------------------|-----------------------------------------|
| QuizEngine.answerQuestion()| **Do one thing**<br>Funktionen utför en kontroll av ifall frågan är rätt eller inte samt tilldelar eventuellt poäng och utlöser en händelse (antingen för rätt eller fel), kan troligtvis refaktoreras till en tydligare sturktur.<br><br>**Have no side effects**<br>Sidoeffekten av att tilldela poäng vid ett rätt svar är inte uppenbar. Jag är lite kluven då problem domänen av ett quiz innefattar poängtilldelning vid rätt svar som norm, så på ett sätt bör detta vara uppenbart men namngivningen och strukturen gör det inte uppenbart för en läsare.|
| QuizEngine.startQuiz() | **Use descriptive names** Funktionen har ett beskrivande namn som är baserat på ett verb, som gör det tydligt att förstå vad funktionen gör.<br><br> **small!**<br> Funktionen består av två rader logik, hämta en fråga och utlös en händelse.|
| QuestionBank.addQuestion() | **Error handling is one thing**<br> Funktionen bryter mot denna regel, funktionen innehåller både logik för att lägga till en Question men även validering och felhantering. Felhantering bör brytas ut till egen metod och anropas i addQuestion om behov för validering/felhantering finns|
| QuestionBank.hasQuestions() | **Do one thing** <br>Funktionen utför en sak, returnerar booleanskt värde som visar på ifall det finns frågor eller inte i QuestionBank.<br><br> **small**<br>Funktionen innehåller en rad logik.<br><br>**Use descriptive names**<br> Namnet är relativt tydligt, skulle förslagsvis kunna bytas till containsQuestions() för att skapa ytterliggare tydlighet.|
| Question() | **Function arguments**<br> Constructorn till denna klass tar ett objekt som förväntas ha minst 3 nyckel/värde par, samt ett frivilligt nyckel/värde par. Även fast det är i överkant (**triad** / över **triad** mängd) så tycker jag att det hade blivit mer förvirrande av att skapa ytterliggare klasser då det inte är tydligt hur argumenten skulle kunna förpackas om på ett mer logiskt sätt. Tankar kring ett builder pattern för klassen har funnits för att skapa objektet.|

## Reflektion
Jag insåg att mina funktioner ofta gjorde mer än en sak (bröt mot **do one thing**) samt att flertal funktioner översteg **triads** mängd av argument. Jag hittade bra tillfällen att skapa nya klasser som håller data (Ex; QuestionResult) där anonyma objekt tidigare användes, som möjliggjorde **monadiska** funktioner som tidigare hade flertal parametrar. Mina funktionsnamn tycker jag överlag är bra (**use descriptive names**) där det framgår relativt tydligt vad funktionen gör (ex startQuiz()), samtidigt som vissa funktionener skulle kunna förtydligas yterliggare (**add meaningful context**) i linje med reflektionerna gjorda i tabellen ovan. Jag håller med kapitlena till stor del, speciellt vid arbete med kod i javascript som saknar typsäkerhet. Samtidigt så reflekterar jag över den overhead som blir av att skapa både klasser och funktioner, vilket jag gissar på skulle kunna påverka prestanda negativt. Samtidigt är en onödig prestandaoptimering i sig inte värd kod som är mindre läsbar, så utbytet av prestanda mot läsbarhet är värd för applikationer som inte nödvändigtvis behöver en optimal prestanda.


# Sammanfattande reflektion
Erfarenheterna av min egna kodkvalitet har varit insiktsfulla. För mig blev det ögonöppnande att inse hur många regler som min struktur och kod bröt mot initialt. Mina funktioner bröt nästan alltid mot (**do one thing**) regeln, där jag tänkte mer på att samla ett flöde logiska steg på ett ställe jämfört med att förmedla en tydlig funktion, både i avseende av (**do one thing**) regeln samt (**reveal intent**). Mina funktioner löste i regel ett lite mindre uppdrag, istället för att utföra en specifik handling. Mina metoder innehöll oftast +3 (**triads**) argument, vilket jag då tyckte gav en funktion flexibilitet, men nu efter att ha läst boken och fått nya insikter så siktar jag på **niladic**, **monadic**, **dyadic** eller max **triads** funktioner. Ett exempel på en ändring jag gjorde var att skapa en QuizResultSummary som innhåller en mängd CategorySummary, för att skapa en summering av hur ett quiz har gått, vilket innebär att objekt som dessa ges till funktioner istället för att värden (text, choices, correctChoice, wasCorrect, category, numOfQuestions etc).
Jag funderade även på att implementera ett builder mönster för klasser som naturligt behöver +3 argument där ett skapande av klass inte är helt intuitivt, men valde att i fåtal situationer låta metoder eller klass konstruktors att ta emot fler än tre argument.
Jag tycker att idén om att hålla funktioner små (**small!**) generellt är bra, samtidigt tycker jag att det logiska flödet blir avbrutet mer av att hoppa runt mellan flertal metoder för att förstå vad en samling av dem utför kan störa mer än det hjälper. Personligen försöker jag hålla funktionernas storlek på en rimlig nivå med ungefär en jämn abstraktionsnivå (**one level of abstraction per function**) är det jag personligen upplever som bäst. Att en funktion inte får ha sidoeffekt (**have no side effects**) är något som har tryckts på under utbildningen, men framförallt utifrån perspektivet av att en funktion inte får modifiera argument som skickas till den utan isåntfall ska kopiera dessa, modifiera och returnera den modifierade kopian. Det gav mig ett nytt perspektiv både i hur viktig utformningen är (**do one thing**) och namngivning (**reveal intent**) av en funktion när man inkluderar att en funktion har sidoeffekter ifall den gör något utöver det som kan förväntas av funktionen (baserat på namngivning och kontext), oavsett om den inte modifierar argumentet. Jag har tidigare upplevt att argumentvalidering har varit svår att veta var man ska placera utan att helt förstöra funktionen som tar emot argumentet, men efter att jag läst **error handling is one thing** stycket så insåg jag dels hur mycket mer läsbart det är att ha all argumentvalidering i en separat funktion (som i sig kastar undantag/errors om fel påträffas), samt hur mycket mer nogrann validering av argument blir när man fokuserar på det som en separat del. Jag har hört mycket negativt om clean code på youtube, och förstår hur det kan bli om det går till överdrift, men för mig har det varit otroligt kul och utmananande att granska sin egna kod utifrån clean code perspektivet. Jag ser fram emot att fortsatta skriva om modulen samt att ta med viktiga insikter till framtida projekt.











----> USERNAME VS PLAYERNAME
Märkte att jag benämnde spelaren som user/username ibland och player/playerName. Username har för mig en ton av ett konto (username + password), playerName tycker jag förmedlar tydligare att det inte handlar om ett konto med lösenord.